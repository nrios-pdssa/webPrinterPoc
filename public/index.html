<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>POS Web Printer PoC</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
      .card { max-width: 720px; padding: 16px; border: 1px solid #ddd; border-radius: 12px; }
      button { padding: 12px 14px; border-radius: 10px; border: 1px solid #333; background: #111; color: #fff; font-size: 16px; }
      pre { background: #0b1020; color: #e7e7e7; padding: 12px; border-radius: 10px; overflow: auto; }
      .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
      input { padding: 10px; border-radius: 10px; border: 1px solid #ccc; min-width: 240px; }
      .muted { color: #555; }
    </style>
  </head>
  <body>
    <div class="card">
      <h1>PoC impresión Android (web)</h1>
      <p class="muted">
        Esta página simula el POS web: intenta enviar un ticket a un <b>bridge local</b> en
        <code>127.0.0.1:9123</code> (que después implementará la app Android).
      </p>

      <div class="row">
        <button id="btnTestConnection" style="display:none;">Test de conexión</button>
        <button id="btnTestPrint" style="display:none;">Test de impresión</button>
        <button id="btnTestEscPos" style="display:none;">TEST PRINT ESC/POS CMD</button>
        <button id="btnPrintLogo1Preset" style="display:none;">Imprimir logo 1 (preset)</button>
        <button id="btnPrintText1" style="display:none;">Imprimir texto 1</button>
        <button id="btnWake">Abrir app (deep link wake)</button>
        <button id="btnCheckPrinterService">Checkear printer service en el dispositivo</button>
        <button id="btnListPrinters">Leer impresoras</button>
      </div>

      <h3>Impresoras</h3>
      <div class="row">
        <label>
          Seleccionar:
          <select id="printersDropdown">
            <option value="">(sin datos)</option>
          </select>
        </label>

        <label id="netPathLabel" style="display:none; margin-left: 12px;">
          IP/Path:
          <input id="netPathInput" placeholder="192.168.0.50" />
        </label>
      </div>

      <div class="row" id="btRow" style="display:none;">
        <button id="btnLoadBtDevices">Cargar BT emparejados</button>
        <label>
          Dispositivo BT:
          <select id="btDevicesDropdown">
            <option value="">(sin datos)</option>
          </select>
        </label>
      </div>

      <h3>Texto libre</h3>
      <div class="row">
        <label>
          Texto:
          <input id="customText" placeholder="Hola, esto es una prueba" />
        </label>
        <label>
          Estilo:
          <select id="customTextStyle">
            <option value="normal">Normal</option>
            <option value="bold">Negrita</option>
            <option value="double_strike">Doble golpe</option>
            <option value="bold_double_strike">Negrita + doble golpe</option>
          </select>
        </label>
        <label>
          Tamaño:
          <select id="customTextSize">
            <option value="normal">Normal</option>
            <option value="double_height">Doble alto</option>
            <option value="double_width">Doble ancho</option>
            <option value="quad">Doble alto y ancho</option>
          </select>
        </label>
        <label>
          Alineación:
          <select id="customTextAlign">
            <option value="left">Izquierda</option>
            <option value="center">Centrado</option>
          </select>
        </label>
        <button id="btnPrintText" style="display:none;">Imprimir texto</button>
      </div>

      <h3>Impresión de logo (test)</h3>
      <div class="row">
        <label style="width:100%;">
          Base64:
          <textarea id="logo1Base64" rows="3" style="width:100%;" placeholder="Pegá acá el base64 del logo"></textarea>
        </label>
      </div>
      <div class="row">
        <button id="btnPrintLogo1" style="display:none;">Imprimir logo 1 (test)</button>
      </div>

      <h3>Log</h3>
      <pre id="log"></pre>
    </div>

    <script src="logo1PresetBase64.js"></script>
    <script>
      const logEl = document.getElementById("log");
      const printersDropdownEl = document.getElementById("printersDropdown");
      const netPathLabelEl = document.getElementById("netPathLabel");
      const netPathInputEl = document.getElementById("netPathInput");
      const btRowEl = document.getElementById("btRow");
      const btnLoadBtDevicesEl = document.getElementById("btnLoadBtDevices");
      const btDevicesDropdownEl = document.getElementById("btDevicesDropdown");
      const btnTestConnectionEl = document.getElementById("btnTestConnection");
      const btnTestPrintEl = document.getElementById("btnTestPrint");
      const btnTestEscPosEl = document.getElementById("btnTestEscPos");
      const btnWakeEl = document.getElementById("btnWake");
      const btnCheckPrinterServiceEl = document.getElementById("btnCheckPrinterService");
      const customTextEl = document.getElementById("customText");
      const customTextStyleEl = document.getElementById("customTextStyle");
      const customTextSizeEl = document.getElementById("customTextSize");
      const customTextAlignEl = document.getElementById("customTextAlign");
      const btnPrintTextEl = document.getElementById("btnPrintText");
      const logo1Base64El = document.getElementById("logo1Base64");
      const btnPrintLogo1El = document.getElementById("btnPrintLogo1");
      const btnPrintLogo1PresetEl = document.getElementById("btnPrintLogo1Preset");
      const btnPrintText1El = document.getElementById("btnPrintText1");
      let lastPrinters = [];
      let lastBtDevices = [];

      function log(msg) {
        const line = `[${new Date().toISOString()}] ${msg}`;
        logEl.textContent = `${line}\n${logEl.textContent}`;
      }

      async function checkPrinterServiceFlow() {
        const url = "http://127.0.0.1:9123/check-printer-service";
        log(`POST ${url}`);
        const res = await fetch(url, {
          method: "POST",
          headers: {
            "X-Pos-Token": "dev-token"
          }
        });
        const text = await res.text();
        log(`Respuesta: ${res.status} ${res.statusText} | ${text}`);
      }

      function wakeFlow() {
        const deepLink = "pocprintbridge://wake";
        log(`Intentando abrir deep link: ${deepLink}`);
        try {
          window.location.href = deepLink;
        } catch (e) {
          log(`No se pudo abrir deep link: ${String(e)}`);
        }
      }

      const printerCommands = {
        ESC_INIT: "\x1B\x40",
        ESC_ALIGN_CENTER: "\x1B\x61\x01",
        ESC_ALIGN_LEFT: "\x1B\x61\x00",
        ESC_BOLD_ON: "\x1B\x45\x01",
        ESC_BOLD_OFF: "\x1B\x45\x00",
        GS_DOUBLE_STRIKE_ON: "\x1B\x47\x01",
        GS_DOUBLE_STRIKE_OFF: "\x1B\x47\x00",
        GS_TEXT_SIZE: "\x1D\x21",
        TEXT_NORMAL: "\x00",
        TEXT_DOUBLE_HEIGHT: "\x01",
        TEXT_DOUBLE_WIDTH: "\x10",
        TEXT_QUAD_SIZE: "\x11"
      };

      function strToBytesLatin1(s) {
        const out = new Uint8Array(s.length);
        for (let i = 0; i < s.length; i++) {
          out[i] = s.charCodeAt(i) & 0xff;
        }
        return out;
      }

      function concatBytes(...parts) {
        const total = parts.reduce((acc, p) => acc + p.length, 0);
        const out = new Uint8Array(total);
        let offset = 0;
        for (const p of parts) {
          out.set(p, offset);
          offset += p.length;
        }
        return out;
      }

      function bytesToBase64(bytes) {
        const chunkSize = 0x8000;
        let binary = "";
        for (let i = 0; i < bytes.length; i += chunkSize) {
          const chunk = bytes.subarray(i, i + chunkSize);
          binary += String.fromCharCode(...chunk);
        }
        return btoa(binary);
      }

      function bytesToHexPreview(bytes, maxPrefix = 96, maxSuffix = 48) {
        if (!bytes || bytes.length === 0) return "<empty>";

        const toHexSlice = (from, toExclusive) => {
          const parts = [];
          for (let i = from; i < toExclusive; i++) {
            parts.push(bytes[i].toString(16).toUpperCase().padStart(2, "0"));
          }
          return parts.join(" ");
        };

        const prefixCount = Math.min(maxPrefix, bytes.length);
        const suffixCount = bytes.length > prefixCount ? Math.min(maxSuffix, bytes.length - prefixCount) : 0;
        const prefix = toHexSlice(0, prefixCount);
        if (suffixCount <= 0) return prefix;
        const suffixStart = bytes.length - suffixCount;
        const suffix = toHexSlice(suffixStart, bytes.length);
        return `${prefix} ... ${suffix}`;
      }

      function buildDataPrinterStringForRaw(selectedPrinter) {
        const name = typeof selectedPrinter?.name === "string" ? selectedPrinter.name : "";
        const path = typeof selectedPrinter?.path === "string" ? selectedPrinter.path : "";
        const model = typeof selectedPrinter?.model === "string" ? selectedPrinter.model : "";

        const looksLikeMac = /^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$/.test(path);
        const looksLikeIpv4 = /^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$/.test(path);

        const printerType = name.includes("(NET)")
          ? "NET"
          : name.includes("(BT)")
            ? "BT"
            : looksLikeMac
              ? "BT"
              : looksLikeIpv4
                ? "NET"
                : "USB";

        const printModel = model || name || "null";
        const ethernet = printerType === "NET" || printerType === "BT" ? path : "";

        const dataPrinter = {
          opt: "sendToPrintProtocolComandera",
          printModel,
          ethernet,
          printerType,
          printerOut: "CUSTOM_WORKSTATION",
          printerPackage: "null",
          modo: "printRaw",
          cashdrawer: "NINGUNO",
          fontType: "FONT_B"
        };

        return JSON.stringify(dataPrinter);
      }

      function wrapTextFixedWidth(text, width = 48) {
        const normalized = String(text ?? "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        const out = [];

        for (const line of normalized.split("\n")) {
          if (!line) {
            out.push("");
            continue;
          }

          for (let i = 0; i < line.length; i += width) {
            out.push(line.slice(i, i + width));
          }
        }

        return out;
      }

      function buildFreeTextEscPosBytes(text, style, size, align) {
        const lines = wrapTextFixedWidth(text, 48);
        const lf = "\n";
        const cut = "\x1D\x56\x00";

        const alignCmd = align === "center" ? printerCommands.ESC_ALIGN_CENTER : printerCommands.ESC_ALIGN_LEFT;

        const sizeCmd = (() => {
          switch (size) {
            case "double_height":
              return printerCommands.GS_TEXT_SIZE + printerCommands.TEXT_DOUBLE_HEIGHT;
            case "double_width":
              return printerCommands.GS_TEXT_SIZE + printerCommands.TEXT_DOUBLE_WIDTH;
            case "quad":
              return printerCommands.GS_TEXT_SIZE + printerCommands.TEXT_QUAD_SIZE;
            default:
              return printerCommands.GS_TEXT_SIZE + printerCommands.TEXT_NORMAL;
          }
        })();

        const styleOnOff = (() => {
          switch (style) {
            case "bold":
              return {
                on: printerCommands.ESC_BOLD_ON,
                off: printerCommands.ESC_BOLD_OFF
              };
            case "double_strike":
              return {
                on: printerCommands.GS_DOUBLE_STRIKE_ON,
                off: printerCommands.GS_DOUBLE_STRIKE_OFF
              };
            case "bold_double_strike":
              return {
                on: printerCommands.ESC_BOLD_ON + printerCommands.GS_DOUBLE_STRIKE_ON,
                off: printerCommands.ESC_BOLD_OFF + printerCommands.GS_DOUBLE_STRIKE_OFF
              };
            default:
              return {
                on: "",
                off: ""
              };
          }
        })();

        let s = "";
        s += printerCommands.ESC_INIT;
        s += alignCmd;
        s += sizeCmd;
        s += styleOnOff.on;

        for (const line of lines) {
          s += line + lf;
        }

        s += styleOnOff.off;
        s += printerCommands.GS_TEXT_SIZE + printerCommands.TEXT_NORMAL;
        s += printerCommands.ESC_ALIGN_LEFT;
        s += lf + lf + lf + lf + lf + lf + lf;
        s += cut + lf;

        return strToBytesLatin1(s);
      }

      function buildEscPosTestTicketBytes() {
        const now = new Date();
        const dd = String(now.getDate()).padStart(2, "0");
        const mm = String(now.getMonth() + 1).padStart(2, "0");
        const yyyy = String(now.getFullYear());
        const hh = String(now.getHours()).padStart(2, "0");
        const min = String(now.getMinutes()).padStart(2, "0");
        const ss = String(now.getSeconds()).padStart(2, "0");
        const dateStr = `${dd}-${mm}-${yyyy}`;
        const timeStr = `${hh}:${min}:${ss}`;

        const sep = "-".repeat(48);
        const lf = "\n";

        const s =
          printerCommands.ESC_INIT +
          printerCommands.ESC_ALIGN_CENTER +
          printerCommands.ESC_BOLD_ON +
          "IMPRESION DE TEST" + lf +
          printerCommands.ESC_BOLD_OFF +
          printerCommands.ESC_ALIGN_LEFT +
          sep + lf +
          dateStr + lf +
          timeStr + lf +
          sep + lf +
          printerCommands.ESC_BOLD_ON + "TEXTO NEGRITA" + printerCommands.ESC_BOLD_OFF + lf +
          printerCommands.GS_DOUBLE_STRIKE_ON + "TEXTO DOBLE NEGRITA" + printerCommands.GS_DOUBLE_STRIKE_OFF + lf +
          printerCommands.ESC_INIT + printerCommands.ESC_ALIGN_CENTER + "TEXTO CENTRADO" + lf + printerCommands.ESC_ALIGN_LEFT +
          printerCommands.GS_TEXT_SIZE + printerCommands.TEXT_DOUBLE_HEIGHT + "DOBLE ALTO" + lf +
          printerCommands.GS_TEXT_SIZE + printerCommands.TEXT_QUAD_SIZE + "DOBLE ALTO Y ANCHO" + lf +
          printerCommands.GS_TEXT_SIZE + printerCommands.TEXT_NORMAL +
          sep + lf +
          "Comandera Mostrador" + lf + lf + lf + lf + lf + lf + lf;

        // Corte (GS V 0) + LF
        const cut = "\x1D\x56\x00";
        return concatBytes(strToBytesLatin1(s), strToBytesLatin1(cut + lf));
      }

      async function testEscPosFlow() {
        const selected = getSelectedPrinter();
        if (!selected) {
          log("No hay impresora seleccionada para TEST PRINT ESC/POS CMD");
          updateTestButtons();
          return;
        }

        const url = "http://127.0.0.1:9123/print-raw";
        const rawBytes = buildEscPosTestTicketBytes();
        const rawCommandBase64 = bytesToBase64(rawBytes);
        const stringDataPrinter = buildDataPrinterStringForRaw(selected);

        const hexPreview = bytesToHexPreview(rawBytes);

        const payload = {
          stringDataPrinter,
          rawCommandBase64
        };

        log(`POST ${url}`);
        log(`Payload.stringDataPrinter=${stringDataPrinter}`);
        log(`Payload.rawBytes=${rawBytes.length} rawHexPreview=[${hexPreview}]`);
        log(`Payload.rawCommandBase64.length=${rawCommandBase64.length}`);
        const res = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Pos-Token": "dev-token"
          },
          body: JSON.stringify(payload)
        });

        const text = await res.text();
        log(`Respuesta: ${res.status} ${res.statusText} | ${text}`);
        if (res.ok) {
          tryAlertPrinterResponseMessage(text);
        }
      }

      function updateBtEditor() {
        const p = getSelectedPrinter();
        const name = typeof p?.name === "string" ? p.name : "";
        const isBt = name.includes("(BT)");

        btRowEl.style.display = isBt ? "flex" : "none";
        if (!isBt) return;

        const saved = localStorage.getItem(`poc.bt.${name}`) || "";
        if (saved && typeof p === "object") {
          p.path = saved;
        }

        const current = typeof p?.path === "string" ? p.path : "";
        if (current) {
          btDevicesDropdownEl.value = current;
        }
      }

      async function testPrintFlow() {
        const selected = getSelectedPrinter();
        if (!selected) {
          log("No hay impresora seleccionada para Test de impresión");
          updateTestButtons();
          return;
        }

        const url = "http://127.0.0.1:9123/print";
        const payload = { mode: "test", printer: selected };

        log(`POST ${url}`);
        const res = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Pos-Token": "dev-token"
          },
          body: JSON.stringify(payload)
        });

        const raw = await res.text();
        log(`Respuesta: ${res.status} ${res.statusText} | ${raw}`);
        if (res.ok) {
          tryAlertPrinterResponseMessage(raw);
        }
      }

      async function printText1Flow() {
        const selected = getSelectedPrinter();
        if (!selected) {
          log("No hay impresora seleccionada para Imprimir texto 1");
          updateTestButtons();
          return;
        }

        const presetText = "Lorem ipsum dolor sit amet consectetur adipiscing elit, phasellus ad pellentesque iaculis mus vitae, natoque himenaeos id cubilia feugiat porttitor. Scelerisque nunc gravida semper molestie erat eros facilisi accumsan, convallis tincidunt ligula odio vehicula dictumst habitasse, habitant praesent porta volutpat sociosqu curabitur neque. Taciti mattis malesuada dapibus nec molestie morbi sodales hendrerit, lectus ultrices vel fusce tellus cras imperdiet non pellentesque, nostra lacinia interdum conubia natoque inceptos egestas.";

        const url = "http://127.0.0.1:9123/print-text";
        const payload = { printer: selected, text: presetText };

        log(`POST ${url}`);
        log(`payload text len=${presetText.length}`);
        const res = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Pos-Token": "dev-token"
          },
          body: JSON.stringify(payload)
        });

        const raw = await res.text();
        log(`Respuesta: ${res.status} ${res.statusText} | ${raw}`);
        if (res.ok) {
          tryAlertPrinterResponseMessage(raw);
        }
      }

      async function printLogo1Flow() {
        const selected = getSelectedPrinter();
        if (!selected) {
          log("No hay impresora seleccionada para Imprimir logo 1");
          updateTestButtons();
          return;
        }

        const base64 = (logo1Base64El.value ?? "").trim();
        if (!base64) {
          log("Base64 vacío para Imprimir logo 1");
          updateTestButtons();
          return;
        }

        const url = "http://127.0.0.1:9123/print-logo1";
        const payload = { printer: selected, base64 };

        log(`POST ${url}`);
        log(`payload bytes aprox base64=${base64.length}`);

        const res = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Pos-Token": "dev-token"
          },
          body: JSON.stringify(payload)
        });

        const raw = await res.text();
        log(`Respuesta: ${res.status} ${res.statusText} | ${raw}`);
        if (res.ok) {
          tryAlertPrinterResponseMessage(raw);
        }
      }

      async function printCustomTextFlow() {
        const selected = getSelectedPrinter();
        if (!selected) {
          log("No hay impresora seleccionada para Imprimir texto");
          updateTestButtons();
          return;
        }

        const text = String(customTextEl.value ?? "").trim();
        if (!text) {
          log("Texto vacío: no se envía a imprimir");
          updateTestButtons();
          return;
        }

        const style = String(customTextStyleEl?.value ?? "normal");
        const size = String(customTextSizeEl?.value ?? "normal");
        const align = String(customTextAlignEl?.value ?? "left");

        const url = "http://127.0.0.1:9123/print-raw";
        const rawBytes = buildFreeTextEscPosBytes(text, style, size, align);
        const rawCommandBase64 = bytesToBase64(rawBytes);
        const stringDataPrinter = buildDataPrinterStringForRaw(selected);
        const hexPreview = bytesToHexPreview(rawBytes);

        const payload = {
          stringDataPrinter,
          rawCommandBase64
        };

        log(`POST ${url}`);

        log(`Payload.stringDataPrinter=${stringDataPrinter}`);
        log(`Payload.rawBytes=${rawBytes.length} rawHexPreview=[${hexPreview}]`);
        log(`Payload.rawCommandBase64.length=${rawCommandBase64.length}`);

        const res = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Pos-Token": "dev-token"
          },
          body: JSON.stringify(payload)
        });

        const raw = await res.text();
        log(`Respuesta: ${res.status} ${res.statusText} | ${raw}`);
        if (res.ok) {
          tryAlertPrinterResponseMessage(raw);
        }
      }

      function buildSampleTicket() {
        return {
          source: "pos-web",
          ts: Date.now(),
          ticket: {
            orderId: `TEST-${Math.floor(Math.random() * 100000)}`,
            items: [
              { name: "Café", qty: 1, price: 2500 },
              { name: "Medialuna", qty: 2, price: 1200 }
            ],
            total: 4900
          }
        };
      }

      function tryAlertPrinterResponseMessage(rawText) {
        let data;
        try {
          data = JSON.parse(rawText);
        } catch (_e) {
          return;
        }

        const msg = typeof data?.responseMessage === "string" ? data.responseMessage : "";
        if (msg) {
          alert(msg);
        }
      }

      async function testConnectionFlow() {
        const selected = getSelectedPrinter();
        if (!selected) {
          log("No hay impresora seleccionada para Test de conexión");
          updateTestButtons();
          return;
        }

        const url = "http://127.0.0.1:9123/test-connection";
        const payload = { printer: selected };

        log(`POST ${url}`);
        const res = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Pos-Token": "dev-token"
          },
          body: JSON.stringify(payload)
        });

        const text = await res.text();
        log(`Respuesta: ${res.status} ${res.statusText} | ${text}`);
        if (res.ok) {
          tryAlertPrinterResponseMessage(text);
        }
      }

      async function listPrinters() {
        const url = "http://127.0.0.1:9123/list-printers";
        log(`POST ${url}`);

        const res = await fetch(url, {
          method: "POST",
          headers: {
            "X-Pos-Token": "dev-token"
          }
        });

        const text = await res.text();
        log(`Respuesta: ${res.status} ${res.statusText} | ${text}`);

        if (!res.ok) return;

        let data;
        try {
          data = JSON.parse(text);
        } catch (_e) {
          log("No se pudo parsear JSON de /list-printers");
          return;
        }

        const printers = Array.isArray(data)
          ? data
          : Array.isArray(data?.printers)
            ? data.printers
            : Array.isArray(data?.data)
              ? data.data
              : [];

        lastPrinters = printers;

        printersDropdownEl.innerHTML = "";
        if (!printers.length) {
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "(sin impresoras)";
          printersDropdownEl.appendChild(opt);
          return;
        }

        for (let i = 0; i < printers.length; i++) {
          const p = printers[i] ?? {};
          const name = typeof p.name === "string" && p.name.trim() ? p.name.trim() : `Printer ${i + 1}`;
          const opt = document.createElement("option");
          opt.value = String(i);
          opt.textContent = name;
          printersDropdownEl.appendChild(opt);
        }

        updateNetEditor();
        updateBtEditor();
        updateTestButtons();
      }

      async function listBtDevices() {
        const url = "http://127.0.0.1:9123/list-bt-devices";
        log(`POST ${url}`);
        const res = await fetch(url, {
          method: "POST",
          headers: {
            "X-Pos-Token": "dev-token"
          }
        });

        const text = await res.text();
        log(`Respuesta: ${res.status} ${res.statusText} | ${text}`);
        if (!res.ok) return;

        let data;
        try {
          data = JSON.parse(text);
        } catch (_e) {
          log("No se pudo parsear JSON de /list-bt-devices");
          return;
        }

        if (data && typeof data === "object" && typeof data.error === "string") {
          log(`BT error: ${data.error}${data.permission ? ` | perm=${data.permission}` : ""}`);
          return;
        }

        const devices = Array.isArray(data?.devices) ? data.devices : [];
        lastBtDevices = devices;

        btDevicesDropdownEl.innerHTML = "";
        const opt0 = document.createElement("option");
        opt0.value = "";
        opt0.textContent = "(seleccionar)";
        btDevicesDropdownEl.appendChild(opt0);

        for (let i = 0; i < devices.length; i++) {
          const d = devices[i] ?? {};
          const name = typeof d.name === "string" ? d.name : "";
          const address = typeof d.address === "string" ? d.address : "";
          const opt = document.createElement("option");
          opt.value = address;
          opt.textContent = name && address ? `${name} (${address})` : address || name || `BT ${i + 1}`;
          btDevicesDropdownEl.appendChild(opt);
        }

        const p = getSelectedPrinter();
        if (p) {
          const saved = localStorage.getItem(`poc.bt.${p.name ?? ""}`) || "";
          if (saved) {
            btDevicesDropdownEl.value = saved;
          }
        }

        updateBtEditor();
        updateTestButtons();
      }

      function getSelectedPrinter() {
        const idx = Number(printersDropdownEl.value);
        if (!Number.isFinite(idx)) return null;
        return lastPrinters[idx] ?? null;
      }

      function updateNetEditor() {
        const p = getSelectedPrinter();
        const name = typeof p?.name === "string" ? p.name : "";
        const isNet = name.includes("(NET)");

        netPathLabelEl.style.display = isNet ? "inline-block" : "none";
        if (isNet) {
          const path = typeof p?.path === "string" ? p.path : "";
          netPathInputEl.value = path;
        } else {
          netPathInputEl.value = "";
        }
      }

      function updateTestButtons() {
        const selected = getSelectedPrinter();
        const hasSelection = Boolean(selected);

        btnTestConnectionEl.style.display = hasSelection ? "inline-block" : "none";
        btnTestPrintEl.style.display = hasSelection ? "inline-block" : "none";
        btnTestEscPosEl.style.display = hasSelection ? "inline-block" : "none";

        const text = (customTextEl.value ?? "").trim();
        const hasText = text.length > 0;
        btnPrintTextEl.style.display = hasSelection && hasText ? "inline-block" : "none";

        const base64 = (logo1Base64El.value ?? "").trim();
        const hasBase64 = base64.length > 0;
        btnPrintLogo1El.style.display = hasSelection && hasBase64 ? "inline-block" : "none";

        btnPrintLogo1PresetEl.style.display = hasSelection ? "inline-block" : "none";

        btnPrintText1El.style.display = hasSelection ? "inline-block" : "none";
      }

      document.getElementById("btnListPrinters").addEventListener("click", async () => {
        try {
          await listPrinters();
        } catch (e) {
          log(`Fallo list printers: ${String(e)}`);
          log("Abrí la app 1 vez (launcher) para iniciar el Foreground Service del bridge y reintentá.");
        }
      });

      printersDropdownEl.addEventListener("change", () => {
        const idx = Number(printersDropdownEl.value);
        const p = Number.isFinite(idx) ? lastPrinters[idx] : null;
        if (p) {
          try {
            log(`Impresora seleccionada: ${p.name ?? "(sin name)"} | ${JSON.stringify(p)}`);
          } catch (_e) {
            log(`Impresora seleccionada: ${p.name ?? "(sin name)"}`);
          }
        }

        updateNetEditor();
        updateBtEditor();
        updateTestButtons();
      });

      netPathInputEl.addEventListener("input", () => {
        const idx = Number(printersDropdownEl.value);
        if (!Number.isFinite(idx)) return;

        const p = lastPrinters[idx];
        if (!p || typeof p !== "object") return;

        const name = typeof p.name === "string" ? p.name : "";
        if (!name.includes("(NET)")) return;

        p.path = netPathInputEl.value;
        log(`NET path actualizado para '${p.name ?? "(sin name)"}': ${p.path}`);
      });

      btnLoadBtDevicesEl.addEventListener("click", async () => {
        try {
          await listBtDevices();
        } catch (e) {
          log(`Fallo list bt devices: ${String(e)}`);
        }
      });

      btDevicesDropdownEl.addEventListener("change", () => {
        const p = getSelectedPrinter();
        if (!p || typeof p !== "object") return;

        const name = typeof p.name === "string" ? p.name : "";
        if (!name.includes("(BT)")) return;

        const mac = String(btDevicesDropdownEl.value ?? "").trim();
        if (!mac) return;

        p.path = mac;
        localStorage.setItem(`poc.bt.${name}`, mac);
        log(`BT address actualizado para '${name}': ${mac}`);
        updateTestButtons();
      });

      customTextEl.addEventListener("input", () => {
        updateTestButtons();
      });

      customTextStyleEl.addEventListener("change", updateTestButtons);
      customTextSizeEl.addEventListener("change", updateTestButtons);
      customTextAlignEl.addEventListener("change", updateTestButtons);

      logo1Base64El.addEventListener("input", updateTestButtons);

      btnPrintLogo1El.addEventListener("click", async () => {
        try {
          await printLogo1Flow();
        } catch (e) {
          log(`Fallo Imprimir logo 1: ${String(e)}`);
        }
      });

      btnPrintLogo1PresetEl.addEventListener("click", async () => {
        const prev = logo1Base64El.value;
        try {
          logo1Base64El.value = window.logo1PresetBase64 || logo1PresetBase64;
          updateTestButtons();
          await printLogo1Flow();
        } catch (e) {
          log(`Fallo Imprimir logo 1 preset: ${String(e)}`);
        } finally {
          logo1Base64El.value = prev;
          updateTestButtons();
        }
      });

      btnTestConnectionEl.addEventListener("click", async () => {
        try {
          await testConnectionFlow();
        } catch (e) {
          log(`Fallo Test de conexión: ${String(e)}`);
        }
      });

      btnTestPrintEl.addEventListener("click", async () => {
        try {
          await testPrintFlow();
        } catch (e) {
          log(`Fallo Test de impresión: ${String(e)}`);
        }
      });

      btnTestEscPosEl.addEventListener("click", async () => {
        try {
          await testEscPosFlow();
        } catch (e) {
          log(`Fallo TEST PRINT ESC/POS CMD: ${String(e)}`);
        }
      });

      btnCheckPrinterServiceEl.addEventListener("click", async () => {
        try {
          await checkPrinterServiceFlow();
        } catch (e) {
          log(`Fallo check printer service: ${String(e)}`);
          log("Abrí la app 1 vez (launcher) para iniciar el Foreground Service del bridge y reintentá.");
        }
      });

      btnWakeEl.addEventListener("click", wakeFlow);

      btnPrintTextEl.addEventListener("click", async () => {
        try {
          await printCustomTextFlow();
        } catch (e) {
          log(`Fallo Imprimir texto: ${String(e)}`);
        }
      });

      btnPrintText1El.addEventListener("click", async () => {
        try {
          await printText1Flow();
        } catch (e) {
          log(`Fallo Imprimir texto 1: ${String(e)}`);
        }
      });

      updateTestButtons();

      log("Listo. Tocá 'Imprimir' para probar el bridge local.");
    </script>
  </body>
</html>
